---
phase: 02-learning-metrics-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - static/index.html
  - static/styles.css
  - static/app.js
autonomous: true

must_haves:
  truths:
    - "User sees three charts: Episode Rewards, Steps per Episode, Epsilon Decay"
    - "Charts update in real-time during training without blocking"
    - "User can pause/unpause chart updates while training continues"
    - "User can clear all metrics data"
    - "User can export metrics as CSV"
    - "Statistics panel shows current episode, rolling averages, and best performance"
  artifacts:
    - path: "static/index.html"
      provides: "Chart containers, statistics panel, control buttons"
      contains: "metrics-section"
    - path: "static/styles.css"
      provides: "Chart and statistics styling"
      contains: "chart-container"
    - path: "static/app.js"
      provides: "ChartManager class, chart update logic, export function"
      contains: "ChartManager"
  key_links:
    - from: "static/app.js episode_complete handler"
      to: "ChartManager.addDataPoint"
      via: "method call"
      pattern: "chartManager\\.addDataPoint"
    - from: "static/app.js"
      to: "Chart.js"
      via: "new Chart()"
      pattern: "new Chart"
---

<objective>
Create Chart.js visualization with three charts, statistics panel, and metrics controls.

Purpose: Visual feedback on learning progress with real-time charts, pause/resume capability, data export for external analysis.
Output: Three charts (rewards, steps, epsilon), statistics panel, pause/clear/export controls
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-learning-metrics-dashboard/02-CONTEXT.md
@.planning/phases/02-learning-metrics-dashboard/02-RESEARCH.md
@.planning/phases/02-learning-metrics-dashboard/02-01-SUMMARY.md
@static/index.html
@static/styles.css
@static/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Chart.js and create chart containers in HTML</name>
  <files>static/index.html, static/styles.css</files>
  <action>
**In index.html:**

1. Add Chart.js CDN in head section (after stylesheet link):
   ```html
   <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
   ```

2. Add metrics section after the main-content div, before the sidebar:
   ```html
   <section class="metrics-section">
       <div class="metrics-header">
           <h2>Learning Metrics</h2>
           <div class="metrics-controls">
               <button id="pause-charts-btn" class="btn btn-secondary">Pause Charts</button>
               <button id="clear-metrics-btn" class="btn btn-tertiary">Clear Data</button>
               <button id="export-csv-btn" class="btn btn-tertiary">Export CSV</button>
           </div>
       </div>

       <div class="statistics-panel">
           <div class="stat-item">
               <span class="stat-label">Total Episodes:</span>
               <span class="stat-value" id="stat-total-episodes">0</span>
           </div>
           <div class="stat-item">
               <span class="stat-label">Latest Reward:</span>
               <span class="stat-value" id="stat-latest-reward">-</span>
           </div>
           <div class="stat-item">
               <span class="stat-label">Avg Reward (50 ep):</span>
               <span class="stat-value" id="stat-avg-reward">-</span>
           </div>
           <div class="stat-item">
               <span class="stat-label">Best Reward:</span>
               <span class="stat-value" id="stat-best-reward">- (ep -)</span>
           </div>
           <div class="stat-item">
               <span class="stat-label">Avg Steps (50 ep):</span>
               <span class="stat-value" id="stat-avg-steps">-</span>
           </div>
           <div class="stat-item">
               <span class="stat-label">Current Epsilon:</span>
               <span class="stat-value" id="stat-epsilon">-</span>
           </div>
       </div>

       <div class="charts-container">
           <div class="chart-wrapper">
               <h3>Episode Rewards</h3>
               <canvas id="reward-chart"></canvas>
           </div>
           <div class="chart-wrapper">
               <h3>Steps per Episode</h3>
               <canvas id="steps-chart"></canvas>
           </div>
           <div class="chart-wrapper">
               <h3>Epsilon Decay</h3>
               <canvas id="epsilon-chart"></canvas>
           </div>
       </div>
   </section>
   ```

**In styles.css:**

Add styles for the metrics section (at end of file):
```css
/* ============================================================================
   Metrics Section
   ============================================================================ */

.metrics-section {
    padding: 20px;
    background: #fff;
    border-top: 1px solid #e0e0e0;
}

.metrics-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.metrics-header h2 {
    margin: 0;
    font-size: 1.25rem;
    color: #333;
}

.metrics-controls {
    display: flex;
    gap: 8px;
}

.metrics-controls .btn {
    padding: 6px 12px;
    font-size: 0.85rem;
}

/* Statistics Panel */
.statistics-panel {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
    margin-bottom: 20px;
    padding: 16px;
    background: #f8f9fa;
    border-radius: 8px;
}

.stat-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.stat-label {
    font-size: 0.75rem;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.stat-value {
    font-size: 1.1rem;
    font-weight: 600;
    color: #333;
}

/* Charts Container */
.charts-container {
    display: flex;
    flex-direction: column;
    gap: 24px;
}

.chart-wrapper {
    background: #fff;
    padding: 16px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
}

.chart-wrapper h3 {
    margin: 0 0 12px 0;
    font-size: 1rem;
    color: #555;
}

.chart-wrapper canvas {
    width: 100% !important;
    max-height: 200px;
}

/* Paused state indicator */
.metrics-section.paused .metrics-header::after {
    content: 'PAUSED';
    margin-left: 12px;
    padding: 2px 8px;
    background: #ffc107;
    color: #333;
    font-size: 0.7rem;
    font-weight: 600;
    border-radius: 4px;
}
```

Also update the main container layout to accommodate metrics section. Find the existing `.container` styles and update to:
```css
.container {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
}

.main-content {
    display: flex;
    flex: 1;
}

.grid-section {
    flex: 1;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
}
```

Note: Verify existing container styles before modifying. The goal is metrics section below the grid, full width.
  </action>
  <verify>
Open http://localhost:8000 and verify:
1. Three empty chart canvases are visible below the grid
2. Statistics panel shows with placeholder values
3. Pause Charts, Clear Data, Export CSV buttons are visible
4. Layout looks clean without horizontal scrolling
  </verify>
  <done>
HTML has Chart.js CDN, chart containers, statistics panel, and metrics control buttons. CSS styles the metrics section with responsive grid for statistics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ChartManager class and wire to episode events</name>
  <files>static/app.js</files>
  <action>
Add ChartManager class and wire everything together. Place after EpisodeStatistics class.

**ChartManager class:**
```javascript
class ChartManager {
    constructor() {
        this.rewardChart = null;
        this.stepsChart = null;
        this.epsilonChart = null;
        this.paused = false;
        this.pendingUpdates = [];  // Queue updates while paused
    }

    init() {
        const chartConfig = {
            type: 'line',
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,  // No animation for real-time updates
                scales: {
                    x: {
                        title: { display: true, text: 'Episode' }
                    },
                    y: {
                        beginAtZero: true
                    }
                },
                plugins: {
                    legend: { display: true, position: 'top' }
                }
            }
        };

        // Reward chart (raw + rolling average)
        this.rewardChart = new Chart(document.getElementById('reward-chart'), {
            ...chartConfig,
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Reward',
                        data: [],
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false
                    },
                    {
                        label: 'Rolling Avg (50)',
                        data: [],
                        borderColor: 'rgb(255, 99, 132)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    }
                ]
            }
        });

        // Steps chart (raw + rolling average)
        this.stepsChart = new Chart(document.getElementById('steps-chart'), {
            ...chartConfig,
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Steps',
                        data: [],
                        borderColor: 'rgb(54, 162, 235)',
                        backgroundColor: 'rgba(54, 162, 235, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false
                    },
                    {
                        label: 'Rolling Avg (50)',
                        data: [],
                        borderColor: 'rgb(255, 159, 64)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    }
                ]
            }
        });

        // Epsilon chart (single line)
        this.epsilonChart = new Chart(document.getElementById('epsilon-chart'), {
            ...chartConfig,
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Epsilon',
                        data: [],
                        borderColor: 'rgb(153, 102, 255)',
                        backgroundColor: 'rgba(153, 102, 255, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: true
                    }
                ]
            },
            options: {
                ...chartConfig.options,
                scales: {
                    ...chartConfig.options.scales,
                    y: {
                        beginAtZero: true,
                        max: 1.0
                    }
                }
            }
        });
    }

    addDataPoint(episode, reward, steps, epsilon, avgReward, avgSteps) {
        if (this.paused) {
            this.pendingUpdates.push({ episode, reward, steps, epsilon, avgReward, avgSteps });
            return;
        }

        // Add to reward chart
        this.rewardChart.data.labels.push(episode);
        this.rewardChart.data.datasets[0].data.push(reward);
        this.rewardChart.data.datasets[1].data.push(avgReward);
        this.rewardChart.update('none');

        // Add to steps chart
        this.stepsChart.data.labels.push(episode);
        this.stepsChart.data.datasets[0].data.push(steps);
        this.stepsChart.data.datasets[1].data.push(avgSteps);
        this.stepsChart.update('none');

        // Add to epsilon chart
        this.epsilonChart.data.labels.push(episode);
        this.epsilonChart.data.datasets[0].data.push(epsilon);
        this.epsilonChart.update('none');
    }

    pause() {
        this.paused = true;
        document.querySelector('.metrics-section').classList.add('paused');
    }

    resume() {
        this.paused = false;
        document.querySelector('.metrics-section').classList.remove('paused');

        // Process queued updates
        while (this.pendingUpdates.length > 0) {
            const update = this.pendingUpdates.shift();
            this.addDataPoint(
                update.episode, update.reward, update.steps,
                update.epsilon, update.avgReward, update.avgSteps
            );
        }
    }

    togglePause() {
        if (this.paused) {
            this.resume();
        } else {
            this.pause();
        }
        return this.paused;
    }

    clear() {
        // Clear reward chart
        this.rewardChart.data.labels = [];
        this.rewardChart.data.datasets.forEach(ds => ds.data = []);
        this.rewardChart.update('none');

        // Clear steps chart
        this.stepsChart.data.labels = [];
        this.stepsChart.data.datasets.forEach(ds => ds.data = []);
        this.stepsChart.update('none');

        // Clear epsilon chart
        this.epsilonChart.data.labels = [];
        this.epsilonChart.data.datasets.forEach(ds => ds.data = []);
        this.epsilonChart.update('none');

        // Clear pending updates
        this.pendingUpdates = [];
    }

    async loadFromStorage(storage, stats) {
        const episodes = await storage.loadAll();
        episodes.sort((a, b) => a.episode - b.episode);

        for (const ep of episodes) {
            stats.add(ep.episode, ep.reward, ep.steps);
            this.addDataPoint(
                ep.episode, ep.reward, ep.steps, ep.epsilon,
                stats.getMeanReward(), stats.getMeanSteps()
            );
        }
    }
}
```

**Add global variable:**
```javascript
let chartManager = null;
```

**Update DOMContentLoaded:**
After initializing metricsStorage and episodeStats, add:
```javascript
// Initialize chart manager
chartManager = new ChartManager();
chartManager.init();

// Load existing metrics from IndexedDB
await chartManager.loadFromStorage(metricsStorage, episodeStats);
updateStatisticsDisplay();
```

**Update episode_complete handler:**
Replace the existing console.log-only handler with:
```javascript
wsClient.on('episode_complete', async (data) => {
    console.log('[Metrics] Episode complete:', data);

    // Store in IndexedDB
    await metricsStorage.saveEpisode(data.episode, data.reward, data.steps, data.epsilon);

    // Update statistics
    episodeStats.add(data.episode, data.reward, data.steps);

    // Update charts
    chartManager.addDataPoint(
        data.episode, data.reward, data.steps, data.epsilon,
        episodeStats.getMeanReward(), episodeStats.getMeanSteps()
    );

    // Update statistics display
    updateStatisticsDisplay(data.reward, data.epsilon);
});
```

**Add statistics display update function:**
```javascript
function updateStatisticsDisplay(latestReward = null, currentEpsilon = null) {
    document.getElementById('stat-total-episodes').textContent = episodeStats.totalEpisodes;

    if (latestReward !== null) {
        document.getElementById('stat-latest-reward').textContent = latestReward.toFixed(1);
    }

    const avgReward = episodeStats.getMeanReward();
    document.getElementById('stat-avg-reward').textContent = avgReward > 0 ? avgReward.toFixed(2) : '-';

    const avgSteps = episodeStats.getMeanSteps();
    document.getElementById('stat-avg-steps').textContent = avgSteps > 0 ? avgSteps.toFixed(1) : '-';

    const best = episodeStats.getBest();
    if (best.episode > 0) {
        document.getElementById('stat-best-reward').textContent = `${best.reward.toFixed(1)} (ep ${best.episode})`;
    }

    if (currentEpsilon !== null) {
        document.getElementById('stat-epsilon').textContent = currentEpsilon.toFixed(4);
    }
}
```

**Add button event handlers in DOMContentLoaded:**
```javascript
// Metrics control buttons
document.getElementById('pause-charts-btn').addEventListener('click', () => {
    const isPaused = chartManager.togglePause();
    document.getElementById('pause-charts-btn').textContent = isPaused ? 'Resume Charts' : 'Pause Charts';
});

document.getElementById('clear-metrics-btn').addEventListener('click', async () => {
    if (confirm('Clear all metrics data? This cannot be undone.')) {
        await metricsStorage.clear();
        episodeStats.reset();
        chartManager.clear();
        updateStatisticsDisplay();
        showNotification('Metrics cleared', 'info');
    }
});

document.getElementById('export-csv-btn').addEventListener('click', async () => {
    const episodes = await metricsStorage.loadAll();
    if (episodes.length === 0) {
        showNotification('No data to export', 'error');
        return;
    }

    episodes.sort((a, b) => a.episode - b.episode);

    const header = 'Episode,Reward,Steps,Epsilon,Timestamp\n';
    const rows = episodes
        .map(e => `${e.episode},${e.reward},${e.steps},${e.epsilon},${e.timestamp}`)
        .join('\n');

    const csv = header + rows;
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `rl-metrics-${Date.now()}.csv`;
    a.click();
    URL.revokeObjectURL(url);

    showNotification(`Exported ${episodes.length} episodes`, 'success');
});
```

**Handle window resize for charts:**
```javascript
window.addEventListener('resize', () => {
    if (chartManager) {
        chartManager.rewardChart.resize();
        chartManager.stepsChart.resize();
        chartManager.epsilonChart.resize();
    }
});
```
  </action>
  <verify>
1. Start server and open http://localhost:8000
2. Start training for 20+ episodes
3. Verify:
   - Charts update with each episode (no animation lag)
   - Statistics panel shows current values
   - Rolling average lines appear on reward and steps charts
4. Click "Pause Charts" - verify button changes to "Resume Charts" and charts stop updating
5. Let training continue, then click "Resume Charts" - verify queued updates appear
6. Click "Export CSV" - verify CSV file downloads with episode data
7. Click "Clear Data" and confirm - verify charts and stats reset
8. Refresh page - verify persisted data reloads from IndexedDB into charts
  </verify>
  <done>
ChartManager creates three Chart.js charts with real-time updates, pause/resume capability, statistics panel updates every episode, CSV export works, and data reloads from IndexedDB on page refresh.
  </done>
</task>

</tasks>

<verification>
1. Start server: `uv run uvicorn src.gridworld.server:app --reload`
2. Open http://localhost:8000
3. Complete training flow test:
   a. Start training with 50 episodes
   b. Verify charts update smoothly
   c. Verify statistics panel shows rolling averages
   d. Pause charts mid-training, verify updates queue
   e. Resume charts, verify queued updates appear
   f. Export CSV, verify file content
   g. Clear data, verify reset
   h. Start new training, verify fresh data
4. Persistence test:
   a. Run 20 episodes
   b. Refresh page
   c. Verify charts reload from IndexedDB
   d. Verify statistics show historical data
</verification>

<success_criteria>
- Three charts (rewards, steps, epsilon) display real-time data during training
- Each chart shows raw data and rolling average (rewards/steps) or single line (epsilon)
- Statistics panel shows: total episodes, latest reward, avg reward, best reward, avg steps, epsilon
- Pause/Resume button toggles chart updates (queues updates while paused)
- Clear Data button removes all metrics from IndexedDB and charts
- Export CSV downloads file with episode,reward,steps,epsilon,timestamp columns
- Charts reload from IndexedDB on page refresh (persistence works)
- No noticeable training performance degradation
</success_criteria>

<output>
After completion, create `.planning/phases/02-learning-metrics-dashboard/02-02-SUMMARY.md`
</output>
