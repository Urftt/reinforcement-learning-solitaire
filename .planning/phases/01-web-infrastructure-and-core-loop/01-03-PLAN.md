---
phase: 01-web-infrastructure-and-core-loop
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/gridworld/server.py
  - static/app.js
autonomous: true

must_haves:
  truths:
    - "User clicks Start Training and training begins"
    - "Agent position updates in real-time on canvas"
    - "Episode and step counters increment during training"
    - "User clicks Stop Training and training halts immediately"
    - "User clicks Reset and environment returns to initial state"
    - "Visualization updates at 10+ frames per second"
  artifacts:
    - path: "src/gridworld/server.py"
      provides: "Async training loop with time-based WebSocket state broadcasting"
      contains: "async def training_loop"
    - path: "static/app.js"
      provides: "WebSocket client with event handling and UI integration"
      contains: "class WebSocketClient"
  key_links:
    - from: "static/app.js WebSocketClient"
      to: "ws://localhost:8000/ws"
      via: "WebSocket connection"
      pattern: "new WebSocket.*localhost:8000"
    - from: "src/gridworld/server.py training_loop"
      to: "manager.broadcast()"
      via: "training state updates every 100ms (time-based)"
      pattern: "await manager\\.broadcast"
    - from: "static/app.js on('training_update')"
      to: "renderer.update()"
      via: "canvas state update from WebSocket message"
      pattern: "renderer\\.update"
---

<objective>
Wire frontend to backend with WebSocket communication and implement async training loop that broadcasts game state in real-time with time-based updates.

Purpose: Connect the independent frontend and backend components, enabling bidirectional communication for training control and state visualization. This is the integration layer that brings the system to life.

Output: Fully functional training system where user can start/stop training via UI and see agent learning in real-time on the canvas with guaranteed 10+ fps visualization.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-web-infrastructure-and-core-loop/01-CONTEXT.md
@.planning/phases/01-web-infrastructure-and-core-loop/01-RESEARCH.md
@.planning/phases/01-web-infrastructure-and-core-loop/01-01-SUMMARY.md
@.planning/phases/01-web-infrastructure-and-core-loop/01-02-SUMMARY.md
@src/gridworld/config.py
@src/gridworld/environment.py
@src/gridworld/agent.py
@src/gridworld/server.py
</context>

<tasks>

<task type="auto">
  <name>Implement async training loop with time-based state broadcasting</name>
  <files>src/gridworld/server.py</files>
  <action>
    Extend src/gridworld/server.py to add the training loop following RESEARCH.md Pattern 2 (Non-Blocking Training Loop).

    Implementation specifics:
    - Add global training_task variable (stores asyncio.Task reference)
    - Implement async training_loop(env_config, agent_config, num_episodes):
      * Create GridWorldEnv instance from environment.py
      * Create QLearningAgent instance from agent.py
      * Track last_broadcast_time for time-based updates (addresses VIZ-04)
      * Loop for num_episodes:
        - Reset environment, get initial observation
        - Inner loop until done or max_steps:
          * Agent selects action via select_action(obs)
          * Environment steps with env.step(action)
          * Agent updates Q-table via update(obs, action, reward, next_obs, done)
          * **Time-based broadcasting (VIZ-04):** Check if (current_time - last_broadcast_time) >= 0.1 seconds (100ms)
          * If 100ms elapsed: broadcast training_update message with {type, episode, step, agent_pos, epsilon}, update last_broadcast_time
        - After episode: decay epsilon via agent.decay_epsilon()
        - Yield to event loop: await asyncio.sleep(0)
      * After training: broadcast training_complete message
    - Update websocket_endpoint message handler to process commands:
      * "start_training": extract params from payload, create training_task with asyncio.create_task(training_loop(...))
      * "stop_training": cancel training_task if running
      * "reset": cancel training, broadcast reset_complete
      * "save_qtable": call agent.save_q_table(), broadcast save_complete (addresses QL-05)
      * "load_qtable": call agent.load_q_table(), broadcast load_complete with success status (addresses QL-05)
      * "ping": respond with "pong" (heartbeat for connection health)
    - Add proper error handling: catch training exceptions, broadcast error messages to frontend

    Message format (JSON):
    - Outbound: {type: "training_update", data: {episode, step, agent_pos: [x, y], epsilon}}
    - Inbound: {type: "start_training", data: {learning_rate, epsilon, discount_factor, num_episodes}}

    **KEY CHANGE (VIZ-04):** Use time-based broadcasting (every 100ms) instead of step-based (every 10 steps). This guarantees 10 Hz update rate regardless of step duration. Use time.time() or asyncio loop time for tracking.
  </action>
  <verify>
    1. Start server: uvicorn src.gridworld.server:app --reload
    2. Create test client in Python:
    ```python
    import asyncio
    import websockets
    import json
    import time

    async def test():
        async with websockets.connect('ws://localhost:8000/ws') as ws:
            # Start training
            await ws.send(json.dumps({
                "type": "start_training",
                "data": {"learning_rate": 0.1, "epsilon": 1.0, "discount_factor": 0.99, "num_episodes": 10}
            }))

            # Receive updates and measure timing
            last_time = time.time()
            for _ in range(20):
                msg = await ws.recv()
                data = json.loads(msg)
                current_time = time.time()
                interval = current_time - last_time
                print(f"{data['type']}: interval={interval:.3f}s")
                last_time = current_time

            # Verify intervals are ~0.1s (100ms ± 20ms tolerance)

    asyncio.run(test())
    ```
    3. Verify training_update messages arrive every ~100ms (not step-based)
    4. Send stop_training command, verify training stops
    5. Test save_qtable and load_qtable commands work
  </verify>
  <done>
    - Async training_loop function implements full Q-learning episode loop
    - Training loop broadcasts state every 100ms (time-based, not step-based) - VIZ-04 satisfied
    - WebSocket handler processes start_training, stop_training, reset, save_qtable, load_qtable commands
    - Training runs without blocking event loop (WebSocket stays responsive)
    - Epsilon decays correctly over episodes
    - Agent reaches goal and receives rewards correctly
    - Q-table save/load commands work via WebSocket - QL-05 satisfied
  </done>
</task>

<task type="auto">
  <name>Wire frontend WebSocket client to backend and UI with Q-table persistence controls</name>
  <files>static/app.js</files>
  <action>
    Add WebSocket client to static/app.js following RESEARCH.md JavaScript WebSocket Client pattern.

    Implementation specifics:
    - Create WebSocketClient class:
      * Constructor connects to ws://localhost:8000/ws
      * Maintain handlers map for event types
      * on(eventType, callback) registers event handlers
      * send(eventType, data) sends JSON messages to backend
      * reconnect() handles connection recovery (3-second delay)
    - Instantiate WebSocketClient on page load
    - Register event handlers:
      * "training_update": update renderer state, update episode/step counters in UI
      * "training_complete": show completion message, re-enable Start button
      * "reset_complete": reset renderer to initial state, clear counters
      * "save_complete": show "Q-table saved" notification (addresses QL-05)
      * "load_complete": show "Q-table loaded" or error notification (addresses QL-05)
      * "error": display error message in UI (console.error + alert or toast)
    - Wire UI buttons to WebSocket:
      * Start button click: read params from inputs, send start_training with config payload, disable Start/enable Stop, lock parameter inputs
      * Stop button click: send stop_training, enable Start/disable Stop, unlock parameter inputs
      * Reset button click: send reset
      * **Save Q-table button (new):** send save_qtable command (addresses QL-05)
      * **Load Q-table button (new):** send load_qtable command (addresses QL-05)
    - Add connection status indicator (optional but helpful): show "Connected" or "Disconnected" in UI

    State management:
    - Track training state locally: {running: false, episode: 0, step: 0}
    - Update UI based on training state
    - Disable parameter inputs during training (per CONTEXT.md decision)
    - Re-enable parameter inputs when training stops

    Handle RESEARCH.md pitfall 2 (WebSocket connection drops): implement reconnect logic with retry backoff.
  </action>
  <verify>
    1. Start backend: uvicorn src.gridworld.server:app --reload
    2. Open static/index.html in browser
    3. Set parameters (learning_rate=0.2, epsilon=1.0, gamma=0.95)
    4. Click Start Training
    5. Verify:
       - Agent position updates on canvas in real-time
       - Episode/step counters increment
       - Trail effect shows agent path
       - Parameter inputs are disabled
       - Updates arrive at ~10 Hz (check DevTools Network tab WebSocket timing)
    6. Click Stop Training
    7. Verify:
       - Training halts
       - Parameter inputs re-enable
    8. Click Save Q-table
    9. Verify:
       - "Q-table saved" notification appears
       - File created at .qtables/agent_latest.json
    10. Click Reset
    11. Click Load Q-table
    12. Verify:
        - "Q-table loaded" notification appears
        - Agent resumes with loaded Q-values
  </verify>
  <done>
    - WebSocketClient establishes connection to backend on page load
    - Training updates from backend render correctly on canvas
    - Episode and step counters update in real-time
    - Start/Stop/Reset buttons send correct WebSocket messages
    - Save/Load Q-table buttons send correct WebSocket messages - QL-05 satisfied
    - Parameter inputs lock during training, unlock when stopped
    - Frontend handles all WebSocket message types gracefully
    - Connection recovery works if server restarts
    - Visualization updates at 10+ Hz (time-based broadcasting) - VIZ-04 satisfied
  </done>
</task>

</tasks>

<verification>
**Integration verification:**
1. Backend starts without errors
2. Frontend connects to WebSocket automatically
3. Start Training initiates backend training loop
4. Agent position updates on canvas at 10+ Hz (VIZ-04)
5. Episode and step counters increment correctly
6. Stop Training halts training immediately
7. Reset returns to initial state
8. Save Q-table persists training state (QL-05)
9. Load Q-table restores training state (QL-05)
10. No WebSocket message flooding (time-based at 100ms intervals)
11. Event loop remains responsive during training

**End-to-end flow:**
1. User loads page → sees initial grid
2. User adjusts parameters → values update
3. User clicks Start → training begins, UI updates in real-time at 10+ fps
4. User clicks Stop → training halts, UI unlocks
5. User clicks Save Q-table → Q-table persists to disk
6. User clicks Reset → state resets to initial
7. User clicks Load Q-table → training resumes with loaded Q-values
8. Repeat cycle works correctly
</verification>

<success_criteria>
Plan succeeds when:
1. User can start training via UI and see agent learn in real-time
2. Canvas updates show agent moving through grid at 10+ fps (VIZ-04 satisfied)
3. Episode and step counters track training progress
4. Stop and Reset controls work immediately
5. Save/Load Q-table controls enable training session continuity (QL-05 satisfied)
6. Parameters lock during training per CONTEXT.md decision
7. Training runs without blocking WebSocket responsiveness
8. System satisfies requirements WEB-01 through WEB-04, TRAIN-01 through TRAIN-06, PARAM-01 through PARAM-05, VIZ-01 through VIZ-04, QL-01 through QL-05
</success_criteria>

<output>
After completion, create `.planning/phases/01-web-infrastructure-and-core-loop/01-03-SUMMARY.md`
</output>
