---
phase: 01-web-infrastructure-and-core-loop
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - src/gridworld/server.py
  - static/app.js
autonomous: true

must_haves:
  truths:
    - "User clicks Start Training and training begins"
    - "Agent position updates in real-time on canvas"
    - "Episode and step counters increment during training"
    - "User clicks Stop Training and training halts immediately"
    - "User clicks Reset and environment returns to initial state"
  artifacts:
    - path: "src/gridworld/server.py"
      provides: "Async training loop with WebSocket state broadcasting"
      contains: "async def training_loop"
    - path: "static/app.js"
      provides: "WebSocket client with event handling and UI integration"
      contains: "class WebSocketClient"
  key_links:
    - from: "static/app.js WebSocketClient"
      to: "ws://localhost:8000/ws"
      via: "WebSocket connection"
      pattern: "new WebSocket.*localhost:8000"
    - from: "src/gridworld/server.py training_loop"
      to: "manager.broadcast()"
      via: "training state updates every N steps"
      pattern: "await manager\\.broadcast"
    - from: "static/app.js on('training_update')"
      to: "renderer.update()"
      via: "canvas state update from WebSocket message"
      pattern: "renderer\\.update"
---

<objective>
Wire frontend to backend with WebSocket communication and implement async training loop that broadcasts game state in real-time.

Purpose: Connect the independent frontend and backend components, enabling bidirectional communication for training control and state visualization. This is the integration layer that brings the system to life.

Output: Fully functional training system where user can start/stop training via UI and see agent learning in real-time on the canvas.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-web-infrastructure-and-core-loop/01-CONTEXT.md
@.planning/phases/01-web-infrastructure-and-core-loop/01-RESEARCH.md
@.planning/phases/01-web-infrastructure-and-core-loop/01-01-SUMMARY.md
@.planning/phases/01-web-infrastructure-and-core-loop/01-02-SUMMARY.md
@src/gridworld/config.py
@src/gridworld/environment.py
@src/gridworld/agent.py
@src/gridworld/server.py
</context>

<tasks>

<task type="auto">
  <name>Implement async training loop with state broadcasting</name>
  <files>src/gridworld/server.py</files>
  <action>
    Extend src/gridworld/server.py to add the training loop following RESEARCH.md Pattern 2 (Non-Blocking Training Loop).

    Implementation specifics:
    - Add global training_task variable (stores asyncio.Task reference)
    - Implement async training_loop(env_config, agent_config, num_episodes):
      * Create GridWorldEnv instance from environment.py
      * Create QLearningAgent instance from agent.py
      * Loop for num_episodes:
        - Reset environment, get initial observation
        - Inner loop until done or max_steps:
          * Agent selects action via select_action(obs)
          * Environment steps with env.step(action)
          * Agent updates Q-table via update(obs, action, reward, next_obs, done)
          * Every 10 steps: broadcast training_update message with {type, episode, step, agent_pos, epsilon}
        - After episode: decay epsilon via agent.decay_epsilon()
        - Yield to event loop: await asyncio.sleep(0)
      * After training: broadcast training_complete message
    - Update websocket_endpoint message handler to process commands:
      * "start_training": extract params from payload, create training_task with asyncio.create_task(training_loop(...))
      * "stop_training": cancel training_task if running
      * "reset": cancel training, broadcast reset_complete
      * "ping": respond with "pong" (heartbeat for connection health)
    - Add proper error handling: catch training exceptions, broadcast error messages to frontend

    Message format (JSON):
    - Outbound: {type: "training_update", data: {episode, step, agent_pos: [x, y], epsilon}}
    - Inbound: {type: "start_training", data: {learning_rate, epsilon, discount_factor, num_episodes}}

    Use CONTEXT.md default: broadcast every 10 steps (UPDATE_INTERVAL = 10). This prevents flooding the WebSocket per RESEARCH.md pitfall 4.
  </action>
  <verify>
    1. Start server: uvicorn src.gridworld.server:app --reload
    2. Create test client in Python:
    ```python
    import asyncio
    import websockets
    import json

    async def test():
        async with websockets.connect('ws://localhost:8000/ws') as ws:
            # Start training
            await ws.send(json.dumps({
                "type": "start_training",
                "data": {"learning_rate": 0.1, "epsilon": 1.0, "discount_factor": 0.99, "num_episodes": 10}
            }))

            # Receive updates
            for _ in range(5):
                msg = await ws.recv()
                data = json.loads(msg)
                print(data)

    asyncio.run(test())
    ```
    3. Verify training_update messages arrive every ~10 steps
    4. Send stop_training command, verify training stops
  </verify>
  <done>
    - Async training_loop function implements full Q-learning episode loop
    - Training loop broadcasts state every 10 steps via WebSocket
    - WebSocket handler processes start_training, stop_training, reset commands
    - Training runs without blocking event loop (WebSocket stays responsive)
    - Epsilon decays correctly over episodes
    - Agent reaches goal and receives rewards correctly
  </done>
</task>

<task type="auto">
  <name>Wire frontend WebSocket client to backend and UI</name>
  <files>static/app.js</files>
  <action>
    Add WebSocket client to static/app.js following RESEARCH.md JavaScript WebSocket Client pattern.

    Implementation specifics:
    - Create WebSocketClient class:
      * Constructor connects to ws://localhost:8000/ws
      * Maintain handlers map for event types
      * on(eventType, callback) registers event handlers
      * send(eventType, data) sends JSON messages to backend
      * reconnect() handles connection recovery (3-second delay)
    - Instantiate WebSocketClient on page load
    - Register event handlers:
      * "training_update": update renderer state, update episode/step counters in UI
      * "training_complete": show completion message, re-enable Start button
      * "reset_complete": reset renderer to initial state, clear counters
      * "error": display error message in UI (console.error + alert or toast)
    - Wire UI buttons to WebSocket:
      * Start button click: read params from inputs, send start_training with config payload, disable Start/enable Stop, lock parameter inputs
      * Stop button click: send stop_training, enable Start/disable Stop, unlock parameter inputs
      * Reset button click: send reset
    - Add connection status indicator (optional but helpful): show "Connected" or "Disconnected" in UI

    State management:
    - Track training state locally: {running: false, episode: 0, step: 0}
    - Update UI based on training state
    - Disable parameter inputs during training (per CONTEXT.md decision)
    - Re-enable parameter inputs when training stops

    Handle RESEARCH.md pitfall 2 (WebSocket connection drops): implement reconnect logic with retry backoff.
  </action>
  <verify>
    1. Start backend: uvicorn src.gridworld.server:app --reload
    2. Open static/index.html in browser
    3. Set parameters (learning_rate=0.2, epsilon=1.0, gamma=0.95)
    4. Click Start Training
    5. Verify:
       - Agent position updates on canvas in real-time
       - Episode/step counters increment
       - Trail effect shows agent path
       - Parameter inputs are disabled
    6. Click Stop Training
    7. Verify:
       - Training halts
       - Parameter inputs re-enable
    8. Click Reset
    9. Verify:
       - Counters reset to 0
       - Agent returns to start position
  </verify>
  <done>
    - WebSocketClient establishes connection to backend on page load
    - Training updates from backend render correctly on canvas
    - Episode and step counters update in real-time
    - Start/Stop/Reset buttons send correct WebSocket messages
    - Parameter inputs lock during training, unlock when stopped
    - Frontend handles all WebSocket message types gracefully
    - Connection recovery works if server restarts
  </done>
</task>

</tasks>

<verification>
**Integration verification:**
1. Backend starts without errors
2. Frontend connects to WebSocket automatically
3. Start Training initiates backend training loop
4. Agent position updates on canvas every ~10 steps
5. Episode and step counters increment correctly
6. Stop Training halts training immediately
7. Reset returns to initial state
8. No WebSocket message flooding (check network tab)
9. Event loop remains responsive during training

**End-to-end flow:**
1. User loads page → sees initial grid
2. User adjusts parameters → values update
3. User clicks Start → training begins, UI updates in real-time
4. User clicks Stop → training halts, UI unlocks
5. User clicks Reset → state resets to initial
6. Repeat cycle works correctly
</verification>

<success_criteria>
Plan succeeds when:
1. User can start training via UI and see agent learn in real-time
2. Canvas updates show agent moving through grid
3. Episode and step counters track training progress
4. Stop and Reset controls work immediately
5. Parameters lock during training per CONTEXT.md decision
6. Training runs without blocking WebSocket responsiveness
7. System satisfies requirements WEB-01 through WEB-04, TRAIN-01 through TRAIN-06, PARAM-01 through PARAM-05, VIZ-01 through VIZ-04, QL-01 through QL-04
</success_criteria>

<output>
After completion, create `.planning/phases/01-web-infrastructure-and-core-loop/01-03-SUMMARY.md`
</output>
