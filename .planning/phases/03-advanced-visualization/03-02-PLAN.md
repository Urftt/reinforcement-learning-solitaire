---
phase: 03-advanced-visualization
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - static/app.js
autonomous: false

must_haves:
  truths:
    - "User sees Q-value heatmap overlay when toggle is ON"
    - "User sees policy arrows overlay when toggle is ON"
    - "Overlays update in real-time during training"
    - "Both overlays can be toggled independently"
    - "Overlays persist (show last state) when training stops"
  artifacts:
    - path: "static/app.js"
      provides: "GridRenderer overlay methods and event handlers"
      contains: "renderHeatmapOverlay"
  key_links:
    - from: "static/app.js"
      to: "GridRenderer.qTable"
      via: "episode_complete handler calls setQTable"
      pattern: "renderer\\.setQTable"
    - from: "static/app.js"
      to: "GridRenderer.showHeatmap"
      via: "toggle change event"
      pattern: "setShowHeatmap"
    - from: "static/app.js"
      to: "render() method"
      via: "conditional overlay rendering"
      pattern: "this\\.showHeatmap.*renderHeatmapOverlay"
---

<objective>
Implement Q-value heatmap and policy arrow rendering in GridRenderer, wire to toggle controls.

Purpose: Allow users to visualize what the agent has learned through color-coded Q-values and directional policy arrows.
Output: Functional heatmap and policy arrow overlays that update in real-time during training.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-advanced-visualization/03-CONTEXT.md
@.planning/phases/03-advanced-visualization/03-RESEARCH.md
@.planning/phases/03-advanced-visualization/03-01-SUMMARY.md
@static/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend GridRenderer with visualization methods</name>
  <files>static/app.js</files>
  <action>
Extend the GridRenderer class with Q-table storage, overlay rendering methods, and modify render() for layered drawing.

**Add to GridRenderer constructor (after this.maxTrailLength = 20):**

```javascript
// Visualization state
this.qTable = null;
this.showHeatmap = false;
this.showPolicyArrows = false;
```

**Add new methods to GridRenderer class:**

```javascript
// Q-table management
setQTable(qTable) {
    this.qTable = qTable;
}

setShowHeatmap(show) {
    this.showHeatmap = show;
}

setShowPolicyArrows(show) {
    this.showPolicyArrows = show;
}

// Color interpolation: red (low Q-value) to green (high Q-value)
interpolateColor(value) {
    // value: 0.0 = red, 1.0 = green
    const red = Math.round(255 * (1 - value));
    const green = Math.round(255 * value);
    return `rgb(${red}, ${green}, 0)`;
}

// Calculate min/max Q-values for normalization
getQTableRange() {
    if (!this.qTable) return { min: 0, max: 0 };
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x < this.gridSize; x++) {
        for (let y = 0; y < this.gridSize; y++) {
            const maxQ = Math.max(...this.qTable[x][y]);
            min = Math.min(min, maxQ);
            max = Math.max(max, maxQ);
        }
    }
    return { min, max };
}

// Render Q-value heatmap overlay
renderHeatmapOverlay() {
    if (!this.qTable) return;

    const { min, max } = this.getQTableRange();

    for (let x = 0; x < this.gridSize; x++) {
        for (let y = 0; y < this.gridSize; y++) {
            const maxQ = Math.max(...this.qTable[x][y]);
            const normalized = (max === min) ? 0.5 : (maxQ - min) / (max - min);

            // Draw colored cell with semi-transparency
            this.ctx.fillStyle = this.interpolateColor(normalized);
            this.ctx.globalAlpha = 0.5;
            this.ctx.fillRect(
                x * this.cellSize,
                y * this.cellSize,
                this.cellSize,
                this.cellSize
            );
            this.ctx.globalAlpha = 1.0;

            // Draw Q-value text (always visible per CONTEXT.md)
            this.ctx.fillStyle = '#000';
            this.ctx.font = 'bold 11px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            this.ctx.fillText(
                maxQ.toFixed(1),
                (x + 0.5) * this.cellSize,
                (y + 0.5) * this.cellSize
            );
        }
    }
}

// Render policy arrows showing best action(s) per state
renderPolicyArrows() {
    if (!this.qTable) return;

    const arrowSize = this.cellSize * 0.2;

    for (let x = 0; x < this.gridSize; x++) {
        for (let y = 0; y < this.gridSize; y++) {
            const qValues = this.qTable[x][y];
            const maxQ = Math.max(...qValues);

            // Skip unexplored states (all zeros) per CONTEXT.md
            if (maxQ === 0 && Math.min(...qValues) === 0) continue;

            // Find best actions (handle ties per CONTEXT.md)
            const bestActions = qValues
                .map((q, i) => ({ q, i }))
                .filter(a => a.q === maxQ)
                .map(a => a.i);

            const centerX = (x + 0.5) * this.cellSize;
            const centerY = (y + 0.5) * this.cellSize;

            this.ctx.fillStyle = '#333'; // Dark gray for contrast per CONTEXT.md

            for (const action of bestActions) {
                this.drawArrow(centerX, centerY, action, arrowSize);
            }
        }
    }
}

// Draw triangle arrow pointing in action direction
drawArrow(cx, cy, direction, size) {
    // Action encoding: 0=up, 1=down, 2=left, 3=right (per STATE.md decision)
    const angles = [-Math.PI / 2, Math.PI / 2, Math.PI, 0];
    const angle = angles[direction];

    // Offset from center based on direction to avoid overlap
    const offset = this.cellSize * 0.25;
    const offsets = [
        [0, -offset],  // up
        [0, offset],   // down
        [-offset, 0],  // left
        [offset, 0]    // right
    ];
    const [ox, oy] = offsets[direction];

    this.ctx.save();
    this.ctx.translate(cx + ox, cy + oy);
    this.ctx.rotate(angle);

    // Draw triangle pointing right (then rotated)
    this.ctx.beginPath();
    this.ctx.moveTo(size, 0);              // Point
    this.ctx.lineTo(-size * 0.5, -size * 0.6);  // Top-left
    this.ctx.lineTo(-size * 0.5, size * 0.6);   // Bottom-left
    this.ctx.closePath();
    this.ctx.fill();

    this.ctx.restore();
}
```

**Modify the render() method to include overlay layers:**

Replace the existing render() method with layered rendering. The key is drawing in correct z-order:
1. Background (existing)
2. Heatmap overlay (NEW - if enabled)
3. Grid lines (existing)
4. Policy arrows (NEW - if enabled)
5. Obstacles (existing)
6. Trail (existing)
7. Goal (existing)
8. Agent (existing)

```javascript
render() {
    // Clear canvas with background color
    this.ctx.fillStyle = '#f5f5f5';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // Layer 1: Heatmap overlay (under grid lines)
    if (this.showHeatmap && this.qTable) {
        this.renderHeatmapOverlay();
    }

    // Layer 2: Grid lines
    this.ctx.strokeStyle = '#ddd';
    this.ctx.lineWidth = 1;
    for (let i = 0; i <= this.gridSize; i++) {
        const pos = i * this.cellSize;
        this.ctx.beginPath();
        this.ctx.moveTo(pos, 0);
        this.ctx.lineTo(pos, this.canvas.height);
        this.ctx.stroke();
        this.ctx.beginPath();
        this.ctx.moveTo(0, pos);
        this.ctx.lineTo(this.canvas.width, pos);
        this.ctx.stroke();
    }

    // Layer 3: Policy arrows (after grid lines, before obstacles)
    if (this.showPolicyArrows && this.qTable) {
        this.renderPolicyArrows();
    }

    // Layer 4: Obstacles (dark filled squares)
    this.ctx.fillStyle = '#333';
    for (const [x, y] of this.state.obstacles) {
        this.ctx.fillRect(
            x * this.cellSize,
            y * this.cellSize,
            this.cellSize,
            this.cellSize
        );
    }

    // Layer 5: Trail with fading opacity effect
    for (let i = 0; i < this.state.trail.length; i++) {
        const [x, y] = this.state.trail[i];
        const opacity = (i + 1) / this.state.trail.length * 0.3;
        this.ctx.fillStyle = `rgba(100, 150, 255, ${opacity})`;
        this.ctx.fillRect(
            x * this.cellSize + 5,
            y * this.cellSize + 5,
            this.cellSize - 10,
            this.cellSize - 10
        );
    }

    // Layer 6: Goal (green circle)
    const [gx, gy] = this.state.goal_pos;
    this.ctx.fillStyle = '#4caf50';
    this.ctx.beginPath();
    this.ctx.arc(
        (gx + 0.5) * this.cellSize,
        (gy + 0.5) * this.cellSize,
        this.cellSize / 3,
        0,
        Math.PI * 2
    );
    this.ctx.fill();

    // Layer 7: Agent (red circle - top layer)
    if (this.state.agent_pos) {
        const [ax, ay] = this.state.agent_pos;
        this.ctx.fillStyle = '#ff6b6b';
        this.ctx.beginPath();
        this.ctx.arc(
            (ax + 0.5) * this.cellSize,
            (ay + 0.5) * this.cellSize,
            this.cellSize / 2.5,
            0,
            Math.PI * 2
        );
        this.ctx.fill();
    }
}
```

Per CONTEXT.md:
- No animation on value changes (instant updates)
- Keep showing last state when training is paused (do NOT clear qTable)
- Red-to-green gradient (red = low, green = high)
- Display max Q-value numerically on each cell
  </action>
  <verify>
1. Search app.js for "renderHeatmapOverlay" - method should exist
2. Search app.js for "renderPolicyArrows" - method should exist
3. Search app.js for "setQTable" - method should exist
4. Verify render() calls renderHeatmapOverlay when showHeatmap is true
5. No JavaScript syntax errors (load page, check console)
  </verify>
  <done>
GridRenderer has qTable storage, setQTable/setShowHeatmap/setShowPolicyArrows methods, renderHeatmapOverlay and renderPolicyArrows methods, and render() includes layered overlay rendering
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire toggle controls and episode_complete handler</name>
  <files>static/app.js</files>
  <action>
Add event handlers in the DOMContentLoaded block to connect:
1. Toggle switches to renderer methods
2. episode_complete WebSocket handler to store Q-table

**Add toggle event handlers (after the export-csv-btn event listener, around line 940):**

```javascript
// Visualization toggle event handlers
document.getElementById('heatmap-toggle').addEventListener('change', (e) => {
    renderer.setShowHeatmap(e.target.checked);
});

document.getElementById('policy-toggle').addEventListener('change', (e) => {
    renderer.setShowPolicyArrows(e.target.checked);
});
```

**Modify the episode_complete handler to store Q-table:**

Find the existing wsClient.on('episode_complete', ...) handler (around line 859) and add Q-table storage after the existing code:

```javascript
wsClient.on('episode_complete', async (data) => {
    console.log('[Metrics] Episode complete:', data);

    // Store in IndexedDB
    await metricsStorage.saveEpisode(data.episode, data.reward, data.steps, data.epsilon);

    // Update statistics
    episodeStats.add(data.episode, data.reward, data.steps);

    // Update charts
    chartManager.addDataPoint(
        data.episode, data.reward, data.steps, data.epsilon,
        episodeStats.getMeanReward(), episodeStats.getMeanSteps()
    );

    // Update statistics display
    updateStatisticsDisplay(data.reward, data.epsilon);

    // Store Q-table for visualization (NEW)
    if (data.q_table) {
        renderer.setQTable(data.q_table);
    }
});
```

Per CONTEXT.md:
- Update overlays every episode (not throttled)
- No animation - instant value changes
- Keep showing last state when training is paused (qTable is retained)
  </action>
  <verify>
1. Open http://localhost:8000 in browser
2. Turn ON "Q-Value Heatmap" toggle
3. Start training for 10+ episodes
4. Verify grid shows colored cells (red-to-green gradient based on Q-values)
5. Verify Q-value numbers are displayed in each cell
6. Turn ON "Policy Arrows" toggle
7. Verify triangular arrows appear pointing in best action direction
8. Verify arrows are visible for explored cells only (no arrows on all-zero cells early in training)
9. Stop training - verify overlays persist (still visible)
10. Turn toggles OFF - verify overlays disappear
  </verify>
  <done>
Toggle switches control heatmap/arrow display, Q-table updates in real-time during training, overlays persist after training stops
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Q-value heatmap and policy arrow visualization system</what-built>
  <how-to-verify>
1. Open http://localhost:8000
2. Turn ON both "Q-Value Heatmap" and "Policy Arrows" toggles
3. Start training with 100 episodes
4. Observe:
   - Grid cells are colored from red (low Q-value) to green (high Q-value)
   - Each cell shows the max Q-value as a number (e.g., "-5.2", "0.0", "2.1")
   - Small triangular arrows point in the best action direction
   - Cells with tied best actions show multiple arrows
   - Unexplored cells (early training) have no arrows
   - Agent (red circle), goal (green circle), and obstacles remain visible on top
5. Toggle heatmap OFF while arrows stay ON - verify independent control
6. Stop training - verify overlays persist showing learned values
7. Turn both toggles OFF - verify grid returns to normal appearance
8. Refresh page - verify toggles reset to OFF (not persisted)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues observed</resume-signal>
</task>

</tasks>

<verification>
1. Q-value heatmap displays correctly when toggle is ON
2. Policy arrows display correctly when toggle is ON
3. Both overlays update in real-time during training
4. Overlays are independent (can toggle each separately)
5. Overlays persist when training stops
6. Agent/goal/obstacles remain visible on top of overlays
7. No performance issues during training with overlays enabled
</verification>

<success_criteria>
- User can see Q-value heatmap with red-to-green gradient
- User can see policy arrows showing best actions
- Visualizations update every episode during training
- Both toggles work independently
- No visual artifacts or z-order issues (agent visible on top)
- Toggles default to OFF on page load
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-visualization/03-02-SUMMARY.md`
</output>
