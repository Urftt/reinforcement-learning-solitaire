---
phase: 02-learning-metrics-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/gridworld/server.py
  - static/app.js
autonomous: true

must_haves:
  truths:
    - "Server broadcasts episode_complete event with reward, steps, epsilon after each episode"
    - "Frontend stores episode metrics in IndexedDB for persistence"
    - "Rolling statistics are computed client-side for display"
  artifacts:
    - path: "src/gridworld/server.py"
      provides: "episode_complete WebSocket broadcast"
      contains: "episode_complete"
    - path: "static/app.js"
      provides: "MetricsStorage class with IndexedDB, EpisodeStatistics class"
      contains: "MetricsStorage"
  key_links:
    - from: "src/gridworld/server.py"
      to: "static/app.js"
      via: "WebSocket episode_complete event"
      pattern: "episode_complete"
    - from: "static/app.js MetricsStorage"
      to: "IndexedDB"
      via: "idb operations"
      pattern: "openDB.*rlMetrics"
---

<objective>
Add backend metrics emission and frontend data layer for learning metrics dashboard.

Purpose: Foundation for real-time metrics visualization. Backend emits episode-level events; frontend stores in IndexedDB and computes rolling statistics.
Output: episode_complete WebSocket event, MetricsStorage class, EpisodeStatistics class
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-learning-metrics-dashboard/02-CONTEXT.md
@.planning/phases/02-learning-metrics-dashboard/02-RESEARCH.md
@src/gridworld/server.py
@static/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add episode_complete WebSocket event to training loop</name>
  <files>src/gridworld/server.py</files>
  <action>
Modify the training_loop() function to broadcast an episode_complete event after each episode finishes.

1. Track episode metrics during the episode loop:
   - total_reward: Sum of rewards received during episode
   - total_steps: Number of steps in episode (already tracked as `step`)

2. After the episode while loop completes (after `agent.decay_epsilon()`), broadcast:
   ```python
   await manager.broadcast({
       "type": "episode_complete",
       "data": {
           "episode": episode + 1,
           "reward": total_reward,
           "steps": step,
           "epsilon": float(agent.epsilon),
       },
   })
   ```

3. Initialize total_reward = 0 at episode start, accumulate with `total_reward += reward` after each step.

Keep existing training_update broadcasts for step-by-step visualization. The episode_complete event is additional, not a replacement.
  </action>
  <verify>
Run server with `uv run uvicorn src.gridworld.server:app --reload` and check logs show "episode_complete" broadcasts. Or add a temporary print statement: `print(f"[Episode {episode+1}] Broadcasting episode_complete: reward={total_reward}, steps={step}")` and verify it fires after each episode.
  </verify>
  <done>
Server broadcasts episode_complete event with reward, steps, epsilon after every training episode completes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MetricsStorage and EpisodeStatistics classes in frontend</name>
  <files>static/app.js</files>
  <action>
Add two new classes to app.js for the metrics data layer. Place them after the GridRenderer class.

**MetricsStorage class (IndexedDB wrapper):**
```javascript
class MetricsStorage {
    constructor() {
        this.db = null;
        this.dbName = 'rlMetrics';
        this.dbVersion = 1;
    }

    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onerror = () => reject(request.error);

            request.onsuccess = () => {
                this.db = request.result;
                resolve();
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('episodes')) {
                    const store = db.createObjectStore('episodes', { keyPath: 'episode' });
                    store.createIndex('timestamp', 'timestamp');
                }
            };
        });
    }

    async saveEpisode(episode, reward, steps, epsilon) {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['episodes'], 'readwrite');
            const store = transaction.objectStore('episodes');
            const request = store.put({
                episode,
                reward,
                steps,
                epsilon,
                timestamp: Date.now()
            });
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    async loadAll() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['episodes'], 'readonly');
            const store = transaction.objectStore('episodes');
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async clear() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['episodes'], 'readwrite');
            const store = transaction.objectStore('episodes');
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    async getCount() {
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction(['episodes'], 'readonly');
            const store = transaction.objectStore('episodes');
            const request = store.count();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }
}
```

**EpisodeStatistics class (rolling averages):**
```javascript
class EpisodeStatistics {
    constructor(windowSize = 50) {
        this.rewardWindow = [];
        this.stepsWindow = [];
        this.windowSize = windowSize;
        this.best = { reward: -Infinity, episode: -1 };
        this.totalEpisodes = 0;
    }

    add(episode, reward, steps) {
        this.totalEpisodes = episode;

        // Update rolling windows
        this.rewardWindow.push(reward);
        this.stepsWindow.push(steps);
        if (this.rewardWindow.length > this.windowSize) {
            this.rewardWindow.shift();
            this.stepsWindow.shift();
        }

        // Track best episode
        if (reward > this.best.reward) {
            this.best = { reward, episode };
        }
    }

    getMeanReward() {
        if (this.rewardWindow.length === 0) return 0;
        return this.rewardWindow.reduce((a, b) => a + b, 0) / this.rewardWindow.length;
    }

    getMeanSteps() {
        if (this.stepsWindow.length === 0) return 0;
        return this.stepsWindow.reduce((a, b) => a + b, 0) / this.stepsWindow.length;
    }

    getBest() {
        return this.best;
    }

    reset() {
        this.rewardWindow = [];
        this.stepsWindow = [];
        this.best = { reward: -Infinity, episode: -1 };
        this.totalEpisodes = 0;
    }
}
```

**Wire into initialization:**
1. Add global variables after existing globals:
   ```javascript
   let metricsStorage = null;
   let episodeStats = null;
   ```

2. In DOMContentLoaded, after WebSocket initialization:
   ```javascript
   // Initialize metrics storage
   metricsStorage = new MetricsStorage();
   await metricsStorage.init();

   // Initialize statistics calculator
   episodeStats = new EpisodeStatistics(50);  // 50-episode rolling window
   ```

   Note: Change DOMContentLoaded callback to async: `document.addEventListener('DOMContentLoaded', async () => { ... })`

3. Add WebSocket handler for episode_complete:
   ```javascript
   wsClient.on('episode_complete', async (data) => {
       console.log('[Metrics] Episode complete:', data);

       // Store in IndexedDB
       await metricsStorage.saveEpisode(data.episode, data.reward, data.steps, data.epsilon);

       // Update statistics
       episodeStats.add(data.episode, data.reward, data.steps);

       // Log rolling average (chart integration in Plan 02)
       console.log('[Metrics] Rolling avg reward:', episodeStats.getMeanReward().toFixed(2));
   });
   ```
  </action>
  <verify>
1. Open browser DevTools, go to Application tab > IndexedDB
2. Start training for a few episodes
3. Verify rlMetrics database exists with episodes store
4. Verify console shows "[Metrics] Episode complete" and rolling averages
5. Refresh page, verify episodes are still in IndexedDB (persistence works)
  </verify>
  <done>
MetricsStorage saves episodes to IndexedDB, EpisodeStatistics computes rolling averages, both classes instantiated and wired to episode_complete WebSocket events.
  </done>
</task>

</tasks>

<verification>
1. Start server: `uv run uvicorn src.gridworld.server:app --reload`
2. Open http://localhost:8000 in browser
3. Start training with 10+ episodes
4. Verify:
   - Console shows episode_complete events with reward/steps/epsilon
   - IndexedDB shows episodes in rlMetrics database
   - Rolling averages logged to console after each episode
5. Refresh page, verify IndexedDB data persists
</verification>

<success_criteria>
- Server broadcasts episode_complete with {episode, reward, steps, epsilon} after each episode
- MetricsStorage class stores episodes in IndexedDB with timestamp
- EpisodeStatistics class computes rolling mean of rewards and steps
- Data persists across page refresh (verified via IndexedDB inspection)
- No training performance degradation (episodes still complete quickly)
</success_criteria>

<output>
After completion, create `.planning/phases/02-learning-metrics-dashboard/02-01-SUMMARY.md`
</output>
